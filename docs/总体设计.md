# 书店管理系统总体设计

杨奕辰

## 程序功能概述

本系统是一个基于命令行交互的书店管理系统，通过文件系统持久化存储所有数据，仅在内存中维护少量缓存和控制逻辑。

**功能：**

1. **多级权限管理**：支持游客、顾客、销售人员、店长四级权限，支持嵌套登录（登录栈）。
2. **图书检索与管理**：支持基于 ISBN、书名、作者、关键字的混合查询；支持图书信息的录入、修改和进货。
3. **交易与财务**：处理图书购买请求，自动计算库存和金额；提供财务报表和员工工作日志查询。
4. **持久化存储**：实现基于外存的**块状链表**结构，替代复杂的树形结构，在保证数据有序性的同时降低实现难度，满足低内存占用的约束。

## 主体逻辑说明

### 系统运行

####  初始化：

- 程序启动时，检查是否存在文件存储结构。
- 若为首次运行，初始化文件头，并自动创建默认超级管理员账户 (权限7)。

#### 主循环：

- 读取标准输入的一行指令。
- 调用 命令解析器将指令切分为 Tokens。
- 根据指令关键词分发给对应的子系统模块。
- 捕获执行过程中的异常，输出对应的错误提示或成功信息。

#### 终止：

- 接收到 `quit` 或 `exit` 指令。
- 将内存中所有数据回写到磁盘。
- 关闭所有文件，释放内存。
- 退出。

## 代码文件结构

```
.
├── src
|	└── main.cpp                // 程序入口，包含主循环和命令分发逻辑
└── include
    ├── UserSystem.hpp      // 用户管理子系统（处理 su, register, useradd 等）
    ├── BookSystem.hpp      // 图书管理子系统（处理 show, buy, select 等）
    ├── LogSystem.hpp       // 日志子系统（处理 log, report 等）
    ├── SystemManager.hpp   // 整合各子系统，管理 Session 栈
    ├── BlockManager.hpp    // 块文件读写管理器（即 MemoryRiver）
    └── BlockList.hpp       // 块状链表模板类（核心数据结构）
```

## 功能设计

### 功能结构图

```
System[书店管理系统]

System --> Auth[账户子系统]
Auth --> A1[登录/注销/嵌套栈]
Auth --> A2[用户注册/创建/删除]
Auth --> A3[密码修改]

System --> Book[图书子系统]
Book --> B1[多条件查询]
Book --> B2[购买/进货]
Book --> B3[图书信息修改]
Book --> B4[图书选中状态维持]

System --> Log[日志子系统]
Log --> L1[交易日志记录]
Log --> L2[财务报表生成]
Log --> L3[操作历史查询]

Auth -.-> Storage[数据存储层(块状链表/文件)]
Book -.-> Storage
Log -.-> Storage
```

### 模块功能详述

1. **账户模块**：
   - 维护 `UserID` 到 `UserInfo` 的映射。
   - 使用**块状链表**存储 `UserID`，保持 ID 有序，支持二分查找（块内）和裂块操作，确保登录和鉴权操作的高效性。
2. **图书模块**：
   - 图书信息包含多个可搜索字段，均使用块状链表进行索引。
   - **主索引**：`ISBN` -> `BookData` (块状链表，Key 为 ISBN，Value 为图书详情)。
   - **辅助索引**：
     - `Name` -> `ISBN` (允许重复 Key 的块状链表)。
     - `Author` -> `ISBN`。
     - `Keyword` -> `ISBN` (由于一本出书有多个 Keyword，需将每个 Keyword 拆解后分别插入链表)。
3. **日志模块**：
   - **交易日志**：记录每笔金额变动。
   - **操作日志**：记录员工的关键操作，用于生成报表。

## 数据库设计

鉴于“**禁止将主体数据存储于内存**”的要求，必须自行设计基于文件的存储格式。本项目选用**块状链表 (Unrolled Linked List)** 作为核心数据结构。

### 存储策略

- **不依赖内存**：`std::map` 或 `std::vector` 仅用于暂存当前处理的一条或几条记录。
- **定长记录**：为了便于文件指针 (`fstream::seekp`, `fstream::seekg`) 快速定位，字符串字段强制补齐到固定长度。
- **块状链表**：
  - **原理**：将数据分块存储，每个块包含多个元素（例如 200-500 个）。块与块之间通过文件指针相连，形成链表。
  - **有序性**：保持所有块内的元素有序，且 Block A 的最大元素 < Block B 的最小元素。
  - **分裂与合并**：当插入导致块满时，将块分裂为两个；当删除导致块过空时，尝试与邻块合并。这保证了较高的空间利用率和查询效率。
  - **性能**：查找复杂度接近 $O(\sqrt{N})$，通过调整块大小可优化 I/O 次数。

### 文件

系统运行时将生成以下文件（每个块状链表 2 个文件）：

1. 存储用户数据的块状链表文件。
2. 存储图书数据的块状链表文件（以 ISBN 为序）。
3. 书名到 ISBN 的索引（块状链表）。
4. 作者到 ISBN 的索引（块状链表）。
5. 关键字到 ISBN 的索引（块状链表）。
6. 财务交易记录。
7. 操作日志。
8. 员工操作记录。

## 类与结构体设计

### `MemoryRiver`

```c++
template<class T, int info_len = 2>
class MemoryRiver {
private:
    fstream file;
    string file_name;
    // 简单的内存缓存，缓存最近读写的 Block
public:
    void initialize(string FN);
    void get_info(int &tmp, int n); // 读文件头信息（如头块位置、块总数）
    void write_info(int tmp, int n);
    
    // 核心读写接口
    void read(T &t, const int index); // 从文件位置 index 读取一个块 T
    void update(T &t, const int index); // 写入一个块
    int write(T &t); // 追加写入新块，返回 index
    void update(T &t, const int index);
    void delete(int index); // 标记块为废弃（可选实现回收逻辑）
};
```

### `BlockList`

依赖 `MemoryRiver` 实现的磁盘块状链表。

```c++
template <class Key, class Value>
class BlockList {
    static const int MAX_SIZE = 300; // 每个块最大元素数量，根据 Key/Value 大小调整
    static const int MIN_SIZE = 100; // 最小合并阈值

    struct Node { // 对应磁盘上的一个块
        std::pair<Key, Value> data[MAX_SIZE]; // 存储的具体数据（有序）
        int size;           // 当前块内元素个数
        int next_block;     // 下一个块在文件中的 index，-1 表示结尾
        int prev_block;     // 上一个块的 index（可选，便于反向遍历）
    };
    
    MemoryRiver<Node> fileManager;
    int head_index; // 头块索引
    
public:
    // 核心接口
    void insert(const Key &key, const Value &val);
    void remove(const Key &key);
    void find(const Key &key, vector<Value> &res); // 支持查找
    void modify(const Key &key, const Value &val);
    
    // 内部辅助
    void split(int node_index, Node &node); // 块分裂
    void merge(int node_index, Node &node); // 块合并（可选）
};
```

### `SystemManager`

```c++
class SystemManager {
private:
    UserSystem userSys;
    BookSystem bookSys;
    LogSystem logSys;
    
    struct Session { ... };
    vector<Session> session_stack; // 登录栈
    
public:
    void run(); // 启动主循环
    void handle_su(vector<string> args);
    void handle_buy(vector<string> args);
    void handle_show(vector<string> args);
    // ...
};
```

## 其他补充说明

### 字符串处理

- 输入参数可能包含空格（如书名），需要通过引号 `"` 识别完整 Token。**注意 Token 长度计算。**
- 关键字 (`Keyword`) 字段以 `|` 分隔，在建立索引时需要拆分。

### 错误处理

- 遇到非法指令（格式错误、参数缺失、**不可见字符**、**在字符串中出现空格**）输出 `Invalid`。
- 逻辑错误（如库存不足、权限不够**（所有操作都要检查权限）**）输出 `Invalid`。
- **输入数字时，小数点前后不能为空，小数点后的数字不能超过两位，数字中不能包含非数字字符，不能有前导零。**
- 所有输出结尾带换行符 `\n`，空内容不输出。

### 精度控制

- 涉及金额的 `double` 类型，在输出时需使用 `std::fixed << std::setprecision(2)` 格式化。

### 开发环境

- 编译器：g++ (支持 C++17 及以上)
- 操作系统：Windows (WSL)
